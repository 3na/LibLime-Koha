#!/usr/bin/env perl

use Koha;
use C4::Context;
use C4::Items qw(GetMarcWithItems);
use WebService::Solr;
use Koha::Solr::IndexStrategy::MARC;
use Koha::Solr::Document::MARC;
use Koha::Changelog::DBLog;
use File::Slurp;
use DateTime;
use Getopt::Long qw(GetOptions);
use Log::Dispatch;
use Log::Dispatch::Screen;
use Carp;

our $log = Log::Dispatch->new();

my ($all) = (0);
my $optcheck = GetOptions(
    'a|all!' => \$all,
    'v|verbose!' => sub {
        $log->add( Log::Dispatch::Screen->new(
                       min_level=>'info', newline=>1, stderr=>1))
    },
    );

my $solr = WebService::Solr->new( C4::Context->config('solr')->{url} );
my $timestamp = get_timestamp($solr);

my $todos;
if ( $all ) {
    $log->info('Collecting all bibs');
    my $bibnums = C4::Context->dbh->selectcol_arrayref(
        'SELECT biblionumber FROM biblio');
    my $now = DateTime->now->ymd . ' ' . DateTime->now->hms;
    $todos = [ map { {id=>$_, action=>'update', stamp=>$now} } @{$bibnums} ];
}
else {
    $log->info("Collecting bibs updated since $timestamp");
    $todos = Koha::Changelog::DBLog
        ->new( rtype => 'biblio' )
        ->get_todos( $timestamp );
}

$log->info('Processing '.@$todos.' bibs');
my $youngest_ts = process_list($solr, $todos);
update_timestamp($solr, $youngest_ts);

exit;


sub process_list {
    my ($solr, $todos) = @_;
    return unless @$todos;

    my $youngest_ts = $todos->[$#$todos]->{stamp};
    $youngest_ts =~ s/ /T/;
    $youngest_ts .= '.000Z';

    my %deletes = map { $_->{id} => 1} grep { $_->{action} ~~ 'delete' } @$todos;
    my %updates = map { $_->{id} => 1} grep { $_->{action} ~~ 'update' } @$todos;

    # Remove deleted items from updates list
    %updates = map { $_ => 1 } grep { ! exists $deletes{$_} } keys %updates;

    my @delete_ids = map { 'bib_'.$_} keys %deletes;
    $log->info('Deleting '. @delete_ids .' docs');
    $solr->delete( {id => \@delete_ids} );

    my $rules_text = read_file( C4::Context->config('solr')->{biblio_rules} );
    my $r = Koha::Solr::IndexStrategy::MARC->new( rules_text => $rules_text );
    my @update_docs;
    my $update_count = 0;
    for ( keys %updates ) {
        my $record = GetMarcWithItems($_);
        next unless $record;
        $update_count++;
        push @update_docs, Koha::Solr::Document::MARC->new(
            record => $record, strategy => $r );
        if (@update_docs >= 500) {
            $log->info('Uploading batch');
            $solr->add( \@update_docs );
            @update_docs = ();
        }
    }
    $solr->add( \@update_docs ) if @update_docs;
    $solr->commit;
    $log->info("Updated $update_count docs");

    return $youngest_ts;
}

sub update_timestamp {
    my ($solr, $youngest_ts) = @_;
    $log->info('Updated timestamp is '.($youngest_ts ? $youngest_ts : '(undef)'));
    return unless $youngest_ts;

    my $metadoc = WebService::Solr::Document->new(
        id => 'bibupdate', rtype => 'meta',
        timestamp => $youngest_ts );
    $solr->update($metadoc);
    return;
}

sub get_timestamp {
    my $solr = shift;

    my $tsres = $solr->search(
        'rtype:meta AND id:bibupdate', {qt => 'advanced', fl => 'timestamp,id'});
    croak 'Failure to query Solr service' unless $tsres->ok;

    my $response = $tsres->content->{response};
    my $metadoc;
    if ($response->{numFound} == 0) {
        # No meta document found, so create one.
        $metadoc = WebService::Solr::Document->new(
            id => 'bibupdate', rtype => 'meta',
            timestamp => '1970-01-01T00:00:00.000Z' );
    }
    else {
        ($metadoc) = $tsres->docs;
    }
    return $metadoc->value_for('timestamp');
}
